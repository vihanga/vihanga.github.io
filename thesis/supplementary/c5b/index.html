<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Hugo 0.55.4">
  
  <title>Chapter 5b: Supplementary Material | Thesis</title>
  
  <link rel="stylesheet" href="/css/thesis-book.css">
  
  
  <link rel="icon" type="image/svg+xml" href="/img/dramatic_v_logo.svg">
  <link rel="apple-touch-icon" href="/img/dramatic_v_logo.svg">
  
  
  <meta property="og:image" content="/img/dramatic_v_logo.svg">
  <meta property="og:image:type" content="image/svg+xml">
  <meta name="twitter:image" content="/img/dramatic_v_logo.svg">
</head>
<body>
  <div class="thesis-wrapper">
    
<div class="thesis-container">
  
  <aside class="thesis-sidebar">
    <div class="thesis-sidebar-content">
      <div class="thesis-logo">
        <img src="/img/dramatic_v_logo.svg" alt="Thesis Logo">
      </div>
      <h3 class="thesis-sidebar-title">Thesis Navigation</h3>
      
      <ul class="thesis-menu">
        <li><a href="/thesis/">← Table of Contents</a></li>
        
        <li class="thesis-menu-section">
          <span class="thesis-menu-section-title">Chapters</span>
          <ul>
            <li><a href="/thesis/chapters/introduction/" >1. Introduction</a></li>
            <li><a href="/thesis/chapters/data-driven-animation/" >2. Data-driven Animation</a></li>
            <li><a href="/thesis/chapters/model-based-rl/" >3. Model-based RL</a></li>
            <li><a href="/thesis/chapters/model-based-animation/" >4. Model-Based Animation</a></li>
            <li><a href="/thesis/chapters/data-driven-rl/" >5. Data-driven RL</a></li>
            <li><a href="/thesis/chapters/latent-dynamics/" >6. Latent Dynamics</a></li>
            <li><a href="/thesis/chapters/conversational-gestures/" >7. Conversational Gestures</a></li>
            <li><a href="/thesis/chapters/conclusion/" >8. Conclusions</a></li>
          </ul>
        </li>
        
        <li class="thesis-menu-section">
          <span class="thesis-menu-section-title">Supplementary</span>
          <ul>
            <li><a href="/thesis/supplementary/c4/">Chapter 4</a></li>
            <li><a href="/thesis/supplementary/c5a/">Chapter 5 - Part A</a></li>
            <li><a href="/thesis/supplementary/c5b/">Chapter 5 - Part B</a></li>
            <li><a href="/thesis/supplementary/c6/">Chapter 6</a></li>
            <li><a href="/thesis/supplementary/c7/">Chapter 7</a></li>
          </ul>
        </li>
        
        <li class="thesis-menu-section">
          <span class="thesis-menu-section-title">Appendices</span>
          <ul>
            <li><a href="/thesis/appendices/a/">A: Serious Games</a></li>
            <li><a href="/thesis/appendices/b/">B: Model-Free RL</a></li>
            <li><a href="/thesis/appendices/c/">C: Supplementary Index</a></li>
            <li><a href="/thesis/appendices/d/">D: Perceptual Evaluation</a></li>
            <li><a href="/thesis/appendices/e/">E: Model-free Results</a></li>
            <li><a href="/thesis/appendices/f/">F: Star Jump Calculation</a></li>
            <li><a href="/thesis/appendices/g/">G: RLAnimate Directory</a></li>
          </ul>
        </li>
      </ul>
      
      <div class="thesis-sidebar-footer">
        <a href="/" class="back-to-main">← Back to Main Site</a>
      </div>
    </div>
  </aside>

  
  <main class="thesis-main">
    <article class="thesis-content">
      <h1>Chapter 5b: Supplementary Material</h1>
      
      
      

<h2 id="video-demonstrations">Video Demonstrations</h2>

<h3 id="advanced-control-strategies">Advanced Control Strategies</h3>

<ul>
<li><strong>Predictive Control</strong>: Model Predictive Control (MPC) for dynamic movements</li>
<li><strong>Hierarchical Control</strong>: Multi-level control architecture demonstrations</li>
<li><strong>Adaptive Behaviors</strong>: Real-time adaptation to changing environments</li>
<li><strong>Multi-objective Optimization</strong>: Balancing multiple animation goals</li>
</ul>

<h3 id="interactive-demonstrations">Interactive Demonstrations</h3>

<ul>
<li>Real-time user control with physics constraints</li>
<li>Style transfer between different motion types</li>
<li>Interactive physics parameter tuning</li>
<li>Live motion editing with physical validity</li>
</ul>

<h2 id="additional-results">Additional Results</h2>

<h3 id="control-performance-metrics">Control Performance Metrics</h3>

<table>
<thead>
<tr>
<th>Control Method</th>
<th>Tracking Error</th>
<th>Computation Time</th>
<th>Robustness Score</th>
</tr>
</thead>

<tbody>
<tr>
<td>PD Control</td>
<td>0.085 rad</td>
<td>0.1 ms</td>
<td>6.<sup>2</sup>&frasl;<sub>10</sub></td>
</tr>

<tr>
<td>Trajectory Opt</td>
<td>0.023 rad</td>
<td>15.2 ms</td>
<td>8.<sup>7</sup>&frasl;<sub>10</sub></td>
</tr>

<tr>
<td>MPC</td>
<td>0.031 rad</td>
<td>8.5 ms</td>
<td>9.<sup>1</sup>&frasl;<sub>10</sub></td>
</tr>

<tr>
<td>Learning-Based</td>
<td>0.042 rad</td>
<td>0.5 ms</td>
<td>7.<sup>8</sup>&frasl;<sub>10</sub></td>
</tr>
</tbody>
</table>

<h3 id="scalability-analysis">Scalability Analysis</h3>

<ul>
<li>Performance with increasing DOF</li>
<li>Multi-character coordination overhead</li>
<li>Memory scaling with simulation complexity</li>
<li>Real-time feasibility boundaries</li>
</ul>

<h2 id="code-examples">Code Examples</h2>

<h3 id="model-predictive-control-implementation">Model Predictive Control Implementation</h3>

<pre><code class="language-python">class ModelPredictiveController:
    def __init__(self, dynamics_model, prediction_horizon=20):
        self.model = dynamics_model
        self.horizon = prediction_horizon
        self.dt = 0.03  # 30Hz control
        
    def solve_mpc(self, x0, reference_trajectory):
        &quot;&quot;&quot;Solve MPC optimization problem&quot;&quot;&quot;
        # Decision variables
        X = cp.Variable((self.model.state_dim, self.horizon + 1))
        U = cp.Variable((self.model.control_dim, self.horizon))
        
        # Objective function
        cost = 0
        for t in range(self.horizon):
            # Tracking cost
            cost += cp.quad_form(X[:, t] - reference_trajectory[:, t], self.Q)
            # Control effort
            cost += cp.quad_form(U[:, t], self.R)
        
        # Constraints
        constraints = [X[:, 0] == x0]
        for t in range(self.horizon):
            # Dynamics constraints
            constraints += [X[:, t + 1] == self.model.dynamics(X[:, t], U[:, t])]
            # Control limits
            constraints += [self.u_min &lt;= U[:, t], U[:, t] &lt;= self.u_max]
            # State constraints (joint limits, etc.)
            constraints += [self.x_min &lt;= X[:, t + 1], X[:, t + 1] &lt;= self.x_max]
        
        # Solve
        problem = cp.Problem(cp.Minimize(cost), constraints)
        problem.solve(solver=cp.OSQP, warm_start=True)
        
        return U[:, 0].value
</code></pre>

<h3 id="hierarchical-control-architecture">Hierarchical Control Architecture</h3>

<pre><code class="language-python">class HierarchicalController:
    def __init__(self):
        self.high_level = TaskPlanner()
        self.mid_level = TrajectoryGenerator()
        self.low_level = JointController()
        
    def control_step(self, state, goal):
        &quot;&quot;&quot;Execute hierarchical control pipeline&quot;&quot;&quot;
        # High-level: Task planning
        task_sequence = self.high_level.plan(state, goal)
        
        # Mid-level: Trajectory generation
        reference_trajectory = self.mid_level.generate(
            current_state=state,
            task=task_sequence[0],
            duration=2.0
        )
        
        # Low-level: Joint control
        joint_torques = self.low_level.track(
            current_state=state,
            reference=reference_trajectory[0]
        )
        
        return joint_torques
</code></pre>

<h3 id="differentiable-physics-integration">Differentiable Physics Integration</h3>

<pre><code class="language-python">import torch

class DifferentiableSimulator(torch.nn.Module):
    def __init__(self, character_model):
        super().__init__()
        self.model = character_model
        
    def forward(self, state, control, dt):
        &quot;&quot;&quot;Differentiable forward dynamics&quot;&quot;&quot;
        # Compute accelerations
        M = self.model.mass_matrix(state)
        C = self.model.coriolis_forces(state)
        g = self.model.gravity_forces(state)
        
        # Joint torques from control
        tau = self.model.control_matrix @ control
        
        # Forward dynamics: M * qdd = tau - C - g
        qdd = torch.linalg.solve(M, tau - C - g)
        
        # Semi-implicit Euler integration
        velocity_new = state.velocity + qdd * dt
        position_new = state.position + velocity_new * dt
        
        return torch.cat([position_new, velocity_new])
</code></pre>

<h2 id="dataset-information">Dataset Information</h2>

<h3 id="controller-training-data">Controller Training Data</h3>

<ul>
<li><strong>State-Action Pairs</strong>: 5M samples from optimal control solutions</li>
<li><strong>Trajectory Library</strong>: 10,000 optimized motion trajectories</li>
<li><strong>Perturbation Data</strong>: Recovery behaviors under 50,000 perturbation scenarios</li>
<li><strong>Style Variations</strong>: 100 different motion styles per base movement</li>
</ul>

<h3 id="benchmark-scenarios">Benchmark Scenarios</h3>

<p>Standardized test cases for controller evaluation:</p>

<ol>
<li><p><strong>Locomotion Tasks</strong></p>

<ul>
<li>Flat ground walking/running</li>
<li>Stair climbing</li>
<li>Slope navigation (various angles)</li>
<li>Stepping stones</li>
</ul></li>

<li><p><strong>Dynamic Movements</strong></p>

<ul>
<li>Jump sequences</li>
<li>Quick direction changes</li>
<li>Balance beam walking</li>
<li>Parkour elements</li>
</ul></li>

<li><p><strong>Robustness Tests</strong></p>

<ul>
<li>Push recovery</li>
<li>Slippery surfaces</li>
<li>Moving platforms</li>
<li>Wind disturbances</li>
</ul></li>
</ol>

<h2 id="computational-resources">Computational Resources</h2>

<h3 id="real-time-performance-requirements">Real-time Performance Requirements</h3>

<pre><code class="language-yaml">minimum_requirements:
  cpu: &quot;Intel i7-8700K or AMD Ryzen 7 2700X&quot;
  ram: &quot;16 GB DDR4&quot;
  gpu: &quot;NVIDIA GTX 1660 or AMD RX 5600 XT&quot;
  
recommended_requirements:
  cpu: &quot;Intel i9-10900K or AMD Ryzen 9 3900X&quot;
  ram: &quot;32 GB DDR4&quot;
  gpu: &quot;NVIDIA RTX 3070 or AMD RX 6800&quot;
</code></pre>

<h3 id="optimization-solver-benchmarks">Optimization Solver Benchmarks</h3>

<table>
<thead>
<tr>
<th>Solver</th>
<th>Problem Size</th>
<th>Solution Time</th>
<th>Accuracy</th>
</tr>
</thead>

<tbody>
<tr>
<td>OSQP</td>
<td>1000 vars</td>
<td>5.2 ms</td>
<td>1e-4</td>
</tr>

<tr>
<td>IPOPT</td>
<td>1000 vars</td>
<td>18.7 ms</td>
<td>1e-6</td>
</tr>

<tr>
<td>Custom GPU</td>
<td>1000 vars</td>
<td>1.8 ms</td>
<td>1e-3</td>
</tr>
</tbody>
</table>

<h2 id="supplementary-figures">Supplementary Figures</h2>

<h3 id="control-analysis">Control Analysis</h3>

<ul>
<li>Control signal frequency analysis</li>
<li>Phase portraits of limit cycles</li>
<li>Stability regions in parameter space</li>
<li>Lyapunov function evolution</li>
</ul>

<h3 id="comparative-studies">Comparative Studies</h3>

<ul>
<li>Traditional vs. optimization-based control</li>
<li>Effect of prediction horizon on performance</li>
<li>Computational cost vs. motion quality trade-offs</li>
<li>Generalization to unseen scenarios</li>
</ul>

<h2 id="advanced-topics">Advanced Topics</h2>

<h3 id="contact-rich-scenarios">Contact-Rich Scenarios</h3>

<p>Special handling for complex contact situations:</p>

<pre><code class="language-python">def handle_multiple_contacts(character, environment):
    &quot;&quot;&quot;Manage multiple simultaneous contacts&quot;&quot;&quot;
    contacts = detect_all_contacts(character, environment)
    
    # Build contact Jacobian
    J_c = build_contact_jacobian(contacts)
    
    # Solve contact forces using LCP
    contact_forces = solve_lcp(
        M=character.mass_matrix,
        J=J_c,
        v=character.velocity,
        restitution=0.1,
        friction=0.8
    )
    
    return contact_forces
</code></pre>

<h3 id="learning-augmented-control">Learning-Augmented Control</h3>

<p>Combining model-based and learning approaches:
- Neural network residual models
- Learned value functions for MPC
- Adaptive parameter tuning
- Online model refinement</p>

<hr />

<p><em>For implementation details and experimental data, visit the project repository.</em></p>

      
      
      <nav class="thesis-chapter-nav">
        
        <a href="https://vihanga.github.io/thesis/supplementary/c6/">← Chapter 6: Supplementary Material</a>
        
        
        
        <a href="https://vihanga.github.io/thesis/supplementary/c5a/">Chapter 5a: Supplementary Material →</a>
        
      </nav>
    </article>
  </main>
</div>

  </div>
</body>
</html>